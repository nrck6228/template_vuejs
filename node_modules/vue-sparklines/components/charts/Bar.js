import RefLine from './RefLine'
import * as utils from './utils'
import dataToPoints from './utils/dataToPoints'

export default {
  name: 'sparkline-bar',
  props: {
    data: {
      type: Array,
      default: () => []
    },
    limit: {
      type: [Number, String],
      default: 3
    },
    width: {
      type: [Number, String],
      default: 100
    },
    height: {
      type: [Number, String],
      default: 30
    },
    margin: {
      type: Number,
      default: 3
    },
    styles: {
      type: Object,
      default: () => ({})
    },
    max: {
      type: Number
    },
    min: {
      type: Number
    },
    spotlight: {
      type: [Number, Boolean],
      default: false
    },
    spotStyles: {
      type: Object,
      default: () => ({
        strokeOpacity: 0,
        fillOpacity: 0
      })
    },
    spotProps: {
      type: Object,
      default: () => ({
        size: 3,
        spotColors: {
          '-1': 'red',
          '0': 'yellow',
          '1': 'green'
        }
      })
    },
    refLineType: { // 'max', 'min', 'mean', 'avg', 'median', 'custom' or false
      type: [String, Boolean],
      default: 'mean'
    },
    refLineStyles: {
      type: Object,
      default: () => ({
        stroke: '#d14',
        strokeOpacity: 1,
        strokeDasharray: '2, 2'
      })
    },
    refLineProps: {
      type: Object,
      default: () => ({
        value: null
      })
    },
    mouseEvents: Function,
    bus: Object
  },
  render (h) {
    const {
      data = [],
      limit,
      width,
      height,
      margin,
      styles,
      max,
      min,
      refLineStyles,
      bus,
      mouseEvents
    } = this

    if (!data.length) {
      return null
    }

    const points = dataToPoints({
      data,
      limit,
      width,
      height,
      margin,
      max,
      min
    })
    const strokeWidth = styles && styles.strokeWidth || 0
    const marginWidth = margin || 0
    const nonLimit = data.length === limit
    const limitedWidth = nonLimit ? (width - limit * (marginWidth + strokeWidth )) / limit : (points && points.length >= 2 ? Math.max(0, points[1].x - points[0].x - strokeWidth - marginWidth) : 0)
    let minWidth

    if (!isNaN(limitedWidth) && limitedWidth < 0) {
      minWidth = 1
    } else {
      minWidth = limitedWidth
    }

    const props = this.$props
    const adjustPos = []
    const barWidth = styles.barWidth || minWidth

    props.points = points
    return h('g', {
      attrs: {
        // transform: `scale(1, -1)`
      }
    }, (() => {
      const items = []

      points.map((p, i) => {
        const curW = Math.ceil(barWidth)
        const curH = Math.ceil(Math.max(0, height - p.y))

        return items.push(h('rect', {
          style: {
            ...props.styles,
            width: `${curW}px`,
            height: `${curH}px`
          },
          attrs: {
            // x: p.x - (barWidth + strokeWidth) / 2,
            x: (() => {
              adjustPos[i] = adjustPos[i] || {}
              if (nonLimit) {
                const curX = Math.ceil((barWidth + strokeWidth + marginWidth) * i + margin)

                adjustPos[i].x = curX + barWidth
                return curX
              } else {
                const curX = Math.ceil(p.x - strokeWidth * i)

                adjustPos[i].x = curX + barWidth
                return curX
              }
            })(),
            // y: -height,
            y: (() => {
              return (adjustPos[i].y = Math.ceil(p.y))
            })(),
            width: curW,
            height: curH,
            rel: data[i]
          },
          props: {
            key: i
          },
          on: utils['evt'](mouseEvents, data[i], p)
        }))
      })
      bus && bus.$emit('setValue', {
        id: `sparkline__${this._uid}`,
        color: styles.stroke || styles.fill || '#fff',
        data,
        points: adjustPos,
        limit,
        type: 'bar'
      })
      refLineStyles && items.push(h(RefLine, { props }))
      return items
    })())
  }
}
